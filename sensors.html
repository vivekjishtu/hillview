<!DOCTYPE html>
<html>
<head>
	<title>Hill View</title>
	<style type="text/css">
	video {
		position: absolute;
		top: 0px;
		left: 0px;
		height: 100%;
		width: 100%;
		 object-fit: cover; 
	}

/*
	video {
	    position: absolute;
	    min-width: 100%;
	    min-height: 100%;
	    top: 50%;
	    left: 50%;
	    transform: translate(-50%, -50%);        
	}
*/
	html, body {
		padding: 0px;
		margin: 0px;
		height: 100%;
		width: 100%;
		overflow: hidden;
		position: relative;
	}

	body, select, input, button  {
		font: menu;
	}

	section {
		z-index: 100;
		    position: absolute;

	}

	.hide {
		display: none;
	} 
	</style>
</head>

<body>
<video autoplay class="hidden"></video>
<section>
	<button id="orientee">Orientation</button>
	<h1>Point your camera towards a hill or mountain to get information about what you are viewing.</h1>
 	
 	<div>
 	  
      <button id="grabFrame" class="hide">Grab Frame</button>
      <button id="takePhoto" class="hide">Take Photo</button>
      <div class="select">
        <label for="videoSource">Video source: </label><select id="videoSource"></select>
      </div>
      <input class="hidden hide" id="zoom" type="range" step="20">
    </div>
	<pre id="data"></pre>

	<pre id="dataGeo"></pre>
	<pre id="dataAcceleration"></pre>
	<pre id="dataAG"></pre>
	<pre id="dataRR"></pre>
	<pre id="dataRI"></pre>

    <img>
    <canvas class="hidden"></canvas>
</section>

<script>
'use strict';


var data = document.querySelector('#data');

function log(message, gId) {
  if(!gId) data.innerHTML += message + '<br />' + data.innerHTML;
  else document.getElementById(gId).innerHTML = message;
}

navigator.geolocation.watchPosition(logPosition);

function logPosition(position) {
  console.log(position);
  log('latitude: ' + position.coords.latitude +
    ', longitude: ' + position.coords.longitude, "dataGeo");
}


function handleDeviceMotion(e) {
  var x = e.acceleration.x;
  var y = e.acceleration.y;
  var z = e.acceleration.z;
  log('Acceleration: ' + x.toFixed(2) + '<br/> ' + y.toFixed(2) + '<br/> ' + z.toFixed(2), "dataAcceleration");

  var xg = e.accelerationIncludingGravity.x;
  var yg = e.accelerationIncludingGravity.y;
  var zg = e.accelerationIncludingGravity.z;
  log('Acceleration including gravity: ' + xg.toFixed(2) + ', ' + yg.toFixed(2) + ', ' + zg.toFixed(2), "dataAG");

  var alpha = e.rotationRate.alpha;
  var beta = e.rotationRate.beta;
  var gamma = e.rotationRate.gamma;
  log('Rotation rate: ' + alpha.toFixed(2) + '<br/> ' + beta.toFixed(2) + '<br/>' + gamma.toFixed(2), "dataRR");

  log('Refresh interval: ' + e.interval, "dataRI");
}

if (window.DeviceMotionEvent) {
  window.ondevicemotion = handleDeviceMotion;
} else {
  log('Device Motion not supported.');
}


var logoElement = document.getElementById('orientee');

function handleDeviceOrientation(e) {
  var transform = 'rotate(' + e.gamma + 'deg) rotate3d(1, 0, 0, ' +
      e.beta + 'deg)';
  logoElement.style.webkitTransform = transform;
  logoElement.style.transform = transform;
}

if (window.DeviceOrientationEvent) {
  window.ondeviceorientation = handleDeviceOrientation;
} else {
  document.querySelector('p#isAvailable').innerHTML =
      'Device Orientation is not available.';
}

/* globals ImageCapture */

// This code is adapted from
// https://cdn.rawgit.com/Miguelao/demos/master/imagecapture.html

// window.isSecureContext could be used for Chrome
var isSecureOrigin = location.protocol === 'https:' ||
location.host === 'localhost';
if (!isSecureOrigin) {
  alert('getUserMedia() must be run from a secure origin: HTTPS or localhost.' +
    '\n\nChanging protocol to HTTPS');
 // location.protocol = 'HTTPS';
}

var constraints;
var imageCapture;
var mediaStream;

var grabFrameButton = document.querySelector('button#grabFrame');
var takePhotoButton = document.querySelector('button#takePhoto');

var canvas = document.querySelector('canvas');
var img = document.querySelector('img');
var video = document.querySelector('video');
var videoSelect = document.querySelector('select#videoSource');
var zoomInput = document.querySelector('input#zoom');

grabFrameButton.onclick = grabFrame;
takePhotoButton.onclick = takePhoto;
videoSelect.onchange = getStream;
zoomInput.oninput = setZoom;

// Get a list of available media input (and output) devices
// then get a MediaStream for the currently selected input device
navigator.mediaDevices.enumerateDevices()
  .then(gotDevices)
  .catch(error => {console.log('enumerateDevices() error: ', error);})
  .then(getStream);

// From the list of media devices available, set up the camera source <select>,
// then get a video stream from the default camera source.
function gotDevices(deviceInfos) {
  for (var i = 0; i !== deviceInfos.length; ++i) {
    var deviceInfo = deviceInfos[i];
    console.log('Found media input or output device: ', deviceInfo);
    var option = document.createElement('option');
    option.value = deviceInfo.deviceId;
    if (deviceInfo.kind === 'videoinput') {
      option.text = deviceInfo.label || 'Camera ' + (videoSelect.length + 1);
      videoSelect.appendChild(option);
    }
  }
}

// Get a video stream from the currently selected camera source.
function getStream() {
  if (mediaStream) {
    mediaStream.getTracks().forEach(track => {
      track.stop();
    });
  }
  var videoSource = videoSelect.value;
  constraints = {
    video: {deviceId: videoSource ? {exact: videoSource} : undefined}
  };
  navigator.mediaDevices.getUserMedia(constraints)
    .then(gotStream)
    .catch(error => {
      console.log('getUserMedia error: ', error);
  });
}

// Display the stream from the currently selected camera source, and then
// create an ImageCapture object, using the video from the stream.
function gotStream(stream) {
  console.log('getUserMedia() got stream: ', stream);
  mediaStream = stream;
  if (window.URL) {
    video.src = window.URL.createObjectURL(stream);
    video.classList.remove('hidden');
  } else {
    video.src = stream;
  }
  imageCapture = new ImageCapture(stream.getVideoTracks()[0]);
  getCapabilities();
}

// Get the PhotoCapabilities for the currently selected camera source.
function getCapabilities() {
  imageCapture.getPhotoCapabilities().then(function(capabilities) {
    console.log('Camera capabilities:', capabilities);
    if (capabilities.zoom.max > 0) {
      zoomInput.min = capabilities.zoom.min;
      zoomInput.max = capabilities.zoom.max;
      zoomInput.value = capabilities.zoom.current;
      zoomInput.classList.remove('hidden');
    }
  }).catch(function(error) {
    console.log('getCapabilities() error: ', error);
  });
}

// Get an ImageBitmap from the currently selected camera source and
// display this with a canvas element.
function grabFrame() {
  imageCapture.grabFrame().then(function(imageBitmap) {
    console.log('Grabbed frame:', imageBitmap);
    canvas.width = imageBitmap.width;
    canvas.height = imageBitmap.height;
    canvas.getContext('2d').drawImage(imageBitmap, 0, 0);
    canvas.classList.remove('hidden');
  }).catch(function(error) {
    console.log('grabFrame() error: ', error);
  });
}

function setZoom() {
  imageCapture.setOptions({
    zoom: zoomInput.value
  });
}

// Get a Blob from the currently selected camera source and
// display this with an img element.
function takePhoto() {
  imageCapture.takePhoto().then(function(blob) {
    console.log('Took photo:', blob);
    img.classList.remove('hidden');
    img.src = URL.createObjectURL(blob);
  }).catch(function(error) {
    console.log('takePhoto() error: ', error);
  });
}
</script>

</body>
</html>
